// Code generated by capnpc-go. DO NOT EDIT.

package protocols

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type Logger capnp.Client

// Logger_TypeID is the unique identifier for the type Logger.
const Logger_TypeID = 0x88306368ea9d4914

func (c Logger) Log(ctx context.Context, params func(Logger_log_Params) error) (Logger_log_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x88306368ea9d4914,
			MethodID:      0,
			InterfaceName: "logger.capnp:Logger",
			MethodName:    "log",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Logger_log_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Logger_log_Results_Future{Future: ans.Future()}, release

}

func (c Logger) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Logger) String() string {
	return "Logger(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Logger) AddRef() Logger {
	return Logger(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Logger) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Logger) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Logger) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Logger) DecodeFromPtr(p capnp.Ptr) Logger {
	return Logger(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Logger) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Logger) IsSame(other Logger) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Logger) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Logger) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Logger_Server is a Logger with a local implementation.
type Logger_Server interface {
	Log(context.Context, Logger_log) error
}

// Logger_NewServer creates a new Server from an implementation of Logger_Server.
func Logger_NewServer(s Logger_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Logger_Methods(nil, s), s, c)
}

// Logger_ServerToClient creates a new Client from an implementation of Logger_Server.
// The caller is responsible for calling Release on the returned Client.
func Logger_ServerToClient(s Logger_Server) Logger {
	return Logger(capnp.NewClient(Logger_NewServer(s)))
}

// Logger_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Logger_Methods(methods []server.Method, s Logger_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x88306368ea9d4914,
			MethodID:      0,
			InterfaceName: "logger.capnp:Logger",
			MethodName:    "log",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Log(ctx, Logger_log{call})
		},
	})

	return methods
}

// Logger_log holds the state for a server call to Logger.log.
// See server.Call for documentation.
type Logger_log struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Logger_log) Args() Logger_log_Params {
	return Logger_log_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Logger_log) AllocResults() (Logger_log_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Logger_log_Results(r), err
}

// Logger_List is a list of Logger.
type Logger_List = capnp.CapList[Logger]

// NewLogger creates a new list of Logger.
func NewLogger_List(s *capnp.Segment, sz int32) (Logger_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Logger](l), err
}

type Logger_Level uint16

// Logger_Level_TypeID is the unique identifier for the type Logger_Level.
const Logger_Level_TypeID = 0xc9fb42427bb06306

// Values of Logger_Level.
const (
	Logger_Level_trace Logger_Level = 0
	Logger_Level_debug Logger_Level = 1
	Logger_Level_info  Logger_Level = 2
	Logger_Level_warn  Logger_Level = 3
	Logger_Level_error Logger_Level = 4
)

// String returns the enum's constant name.
func (c Logger_Level) String() string {
	switch c {
	case Logger_Level_trace:
		return "trace"
	case Logger_Level_debug:
		return "debug"
	case Logger_Level_info:
		return "info"
	case Logger_Level_warn:
		return "warn"
	case Logger_Level_error:
		return "error"

	default:
		return ""
	}
}

// Logger_LevelFromString returns the enum value with a name,
// or the zero value if there's no such value.
func Logger_LevelFromString(c string) Logger_Level {
	switch c {
	case "trace":
		return Logger_Level_trace
	case "debug":
		return Logger_Level_debug
	case "info":
		return Logger_Level_info
	case "warn":
		return Logger_Level_warn
	case "error":
		return Logger_Level_error

	default:
		return 0
	}
}

type Logger_Level_List = capnp.EnumList[Logger_Level]

func NewLogger_Level_List(s *capnp.Segment, sz int32) (Logger_Level_List, error) {
	return capnp.NewEnumList[Logger_Level](s, sz)
}

type Logger_log_Params capnp.Struct

// Logger_log_Params_TypeID is the unique identifier for the type Logger_log_Params.
const Logger_log_Params_TypeID = 0xfa8dcbc9efc6d905

func NewLogger_log_Params(s *capnp.Segment) (Logger_log_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Logger_log_Params(st), err
}

func NewRootLogger_log_Params(s *capnp.Segment) (Logger_log_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Logger_log_Params(st), err
}

func ReadRootLogger_log_Params(msg *capnp.Message) (Logger_log_Params, error) {
	root, err := msg.Root()
	return Logger_log_Params(root.Struct()), err
}

func (s Logger_log_Params) String() string {
	str, _ := text.Marshal(0xfa8dcbc9efc6d905, capnp.Struct(s))
	return str
}

func (s Logger_log_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Logger_log_Params) DecodeFromPtr(p capnp.Ptr) Logger_log_Params {
	return Logger_log_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Logger_log_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Logger_log_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Logger_log_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Logger_log_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Logger_log_Params) Level() Logger_Level {
	return Logger_Level(capnp.Struct(s).Uint16(0))
}

func (s Logger_log_Params) SetLevel(v Logger_Level) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Logger_log_Params) Msg() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Logger_log_Params) HasMsg() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Logger_log_Params) MsgBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Logger_log_Params) SetMsg(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Logger_log_Params_List is a list of Logger_log_Params.
type Logger_log_Params_List = capnp.StructList[Logger_log_Params]

// NewLogger_log_Params creates a new list of Logger_log_Params.
func NewLogger_log_Params_List(s *capnp.Segment, sz int32) (Logger_log_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Logger_log_Params](l), err
}

// Logger_log_Params_Future is a wrapper for a Logger_log_Params promised by a client call.
type Logger_log_Params_Future struct{ *capnp.Future }

func (f Logger_log_Params_Future) Struct() (Logger_log_Params, error) {
	p, err := f.Future.Ptr()
	return Logger_log_Params(p.Struct()), err
}

type Logger_log_Results capnp.Struct

// Logger_log_Results_TypeID is the unique identifier for the type Logger_log_Results.
const Logger_log_Results_TypeID = 0xe5312ae5d0ce5694

func NewLogger_log_Results(s *capnp.Segment) (Logger_log_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Logger_log_Results(st), err
}

func NewRootLogger_log_Results(s *capnp.Segment) (Logger_log_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Logger_log_Results(st), err
}

func ReadRootLogger_log_Results(msg *capnp.Message) (Logger_log_Results, error) {
	root, err := msg.Root()
	return Logger_log_Results(root.Struct()), err
}

func (s Logger_log_Results) String() string {
	str, _ := text.Marshal(0xe5312ae5d0ce5694, capnp.Struct(s))
	return str
}

func (s Logger_log_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Logger_log_Results) DecodeFromPtr(p capnp.Ptr) Logger_log_Results {
	return Logger_log_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Logger_log_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Logger_log_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Logger_log_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Logger_log_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Logger_log_Results_List is a list of Logger_log_Results.
type Logger_log_Results_List = capnp.StructList[Logger_log_Results]

// NewLogger_log_Results creates a new list of Logger_log_Results.
func NewLogger_log_Results_List(s *capnp.Segment, sz int32) (Logger_log_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Logger_log_Results](l), err
}

// Logger_log_Results_Future is a wrapper for a Logger_log_Results promised by a client call.
type Logger_log_Results_Future struct{ *capnp.Future }

func (f Logger_log_Results_Future) Struct() (Logger_log_Results, error) {
	p, err := f.Future.Ptr()
	return Logger_log_Results(p.Struct()), err
}

type LoggerFactory capnp.Client

// LoggerFactory_TypeID is the unique identifier for the type LoggerFactory.
const LoggerFactory_TypeID = 0xf0063aaa378df992

func (c LoggerFactory) Create(ctx context.Context, params func(LoggerFactory_create_Params) error) (LoggerFactory_create_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf0063aaa378df992,
			MethodID:      0,
			InterfaceName: "logger.capnp:LoggerFactory",
			MethodName:    "create",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(LoggerFactory_create_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return LoggerFactory_create_Results_Future{Future: ans.Future()}, release

}

func (c LoggerFactory) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c LoggerFactory) String() string {
	return "LoggerFactory(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c LoggerFactory) AddRef() LoggerFactory {
	return LoggerFactory(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c LoggerFactory) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c LoggerFactory) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c LoggerFactory) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (LoggerFactory) DecodeFromPtr(p capnp.Ptr) LoggerFactory {
	return LoggerFactory(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c LoggerFactory) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c LoggerFactory) IsSame(other LoggerFactory) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c LoggerFactory) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c LoggerFactory) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A LoggerFactory_Server is a LoggerFactory with a local implementation.
type LoggerFactory_Server interface {
	Create(context.Context, LoggerFactory_create) error
}

// LoggerFactory_NewServer creates a new Server from an implementation of LoggerFactory_Server.
func LoggerFactory_NewServer(s LoggerFactory_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(LoggerFactory_Methods(nil, s), s, c)
}

// LoggerFactory_ServerToClient creates a new Client from an implementation of LoggerFactory_Server.
// The caller is responsible for calling Release on the returned Client.
func LoggerFactory_ServerToClient(s LoggerFactory_Server) LoggerFactory {
	return LoggerFactory(capnp.NewClient(LoggerFactory_NewServer(s)))
}

// LoggerFactory_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func LoggerFactory_Methods(methods []server.Method, s LoggerFactory_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf0063aaa378df992,
			MethodID:      0,
			InterfaceName: "logger.capnp:LoggerFactory",
			MethodName:    "create",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Create(ctx, LoggerFactory_create{call})
		},
	})

	return methods
}

// LoggerFactory_create holds the state for a server call to LoggerFactory.create.
// See server.Call for documentation.
type LoggerFactory_create struct {
	*server.Call
}

// Args returns the call's arguments.
func (c LoggerFactory_create) Args() LoggerFactory_create_Params {
	return LoggerFactory_create_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c LoggerFactory_create) AllocResults() (LoggerFactory_create_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LoggerFactory_create_Results(r), err
}

// LoggerFactory_List is a list of LoggerFactory.
type LoggerFactory_List = capnp.CapList[LoggerFactory]

// NewLoggerFactory creates a new list of LoggerFactory.
func NewLoggerFactory_List(s *capnp.Segment, sz int32) (LoggerFactory_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[LoggerFactory](l), err
}

type LoggerFactory_create_Params capnp.Struct

// LoggerFactory_create_Params_TypeID is the unique identifier for the type LoggerFactory_create_Params.
const LoggerFactory_create_Params_TypeID = 0xab98ba1217e0895b

func NewLoggerFactory_create_Params(s *capnp.Segment) (LoggerFactory_create_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LoggerFactory_create_Params(st), err
}

func NewRootLoggerFactory_create_Params(s *capnp.Segment) (LoggerFactory_create_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LoggerFactory_create_Params(st), err
}

func ReadRootLoggerFactory_create_Params(msg *capnp.Message) (LoggerFactory_create_Params, error) {
	root, err := msg.Root()
	return LoggerFactory_create_Params(root.Struct()), err
}

func (s LoggerFactory_create_Params) String() string {
	str, _ := text.Marshal(0xab98ba1217e0895b, capnp.Struct(s))
	return str
}

func (s LoggerFactory_create_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LoggerFactory_create_Params) DecodeFromPtr(p capnp.Ptr) LoggerFactory_create_Params {
	return LoggerFactory_create_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LoggerFactory_create_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LoggerFactory_create_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LoggerFactory_create_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LoggerFactory_create_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LoggerFactory_create_Params) Request() (LoggerRequest, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return LoggerRequest(p.Struct()), err
}

func (s LoggerFactory_create_Params) HasRequest() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LoggerFactory_create_Params) SetRequest(v LoggerRequest) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewRequest sets the request field to a newly
// allocated LoggerRequest struct, preferring placement in s's segment.
func (s LoggerFactory_create_Params) NewRequest() (LoggerRequest, error) {
	ss, err := NewLoggerRequest(capnp.Struct(s).Segment())
	if err != nil {
		return LoggerRequest{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// LoggerFactory_create_Params_List is a list of LoggerFactory_create_Params.
type LoggerFactory_create_Params_List = capnp.StructList[LoggerFactory_create_Params]

// NewLoggerFactory_create_Params creates a new list of LoggerFactory_create_Params.
func NewLoggerFactory_create_Params_List(s *capnp.Segment, sz int32) (LoggerFactory_create_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[LoggerFactory_create_Params](l), err
}

// LoggerFactory_create_Params_Future is a wrapper for a LoggerFactory_create_Params promised by a client call.
type LoggerFactory_create_Params_Future struct{ *capnp.Future }

func (f LoggerFactory_create_Params_Future) Struct() (LoggerFactory_create_Params, error) {
	p, err := f.Future.Ptr()
	return LoggerFactory_create_Params(p.Struct()), err
}
func (p LoggerFactory_create_Params_Future) Request() LoggerRequest_Future {
	return LoggerRequest_Future{Future: p.Future.Field(0, nil)}
}

type LoggerFactory_create_Results capnp.Struct

// LoggerFactory_create_Results_TypeID is the unique identifier for the type LoggerFactory_create_Results.
const LoggerFactory_create_Results_TypeID = 0xaa496e0e25fd2bbb

func NewLoggerFactory_create_Results(s *capnp.Segment) (LoggerFactory_create_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LoggerFactory_create_Results(st), err
}

func NewRootLoggerFactory_create_Results(s *capnp.Segment) (LoggerFactory_create_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LoggerFactory_create_Results(st), err
}

func ReadRootLoggerFactory_create_Results(msg *capnp.Message) (LoggerFactory_create_Results, error) {
	root, err := msg.Root()
	return LoggerFactory_create_Results(root.Struct()), err
}

func (s LoggerFactory_create_Results) String() string {
	str, _ := text.Marshal(0xaa496e0e25fd2bbb, capnp.Struct(s))
	return str
}

func (s LoggerFactory_create_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LoggerFactory_create_Results) DecodeFromPtr(p capnp.Ptr) LoggerFactory_create_Results {
	return LoggerFactory_create_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LoggerFactory_create_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LoggerFactory_create_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LoggerFactory_create_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LoggerFactory_create_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LoggerFactory_create_Results) Logger() Logger {
	p, _ := capnp.Struct(s).Ptr(0)
	return Logger(p.Interface().Client())
}

func (s LoggerFactory_create_Results) HasLogger() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LoggerFactory_create_Results) SetLogger(v Logger) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// LoggerFactory_create_Results_List is a list of LoggerFactory_create_Results.
type LoggerFactory_create_Results_List = capnp.StructList[LoggerFactory_create_Results]

// NewLoggerFactory_create_Results creates a new list of LoggerFactory_create_Results.
func NewLoggerFactory_create_Results_List(s *capnp.Segment, sz int32) (LoggerFactory_create_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[LoggerFactory_create_Results](l), err
}

// LoggerFactory_create_Results_Future is a wrapper for a LoggerFactory_create_Results promised by a client call.
type LoggerFactory_create_Results_Future struct{ *capnp.Future }

func (f LoggerFactory_create_Results_Future) Struct() (LoggerFactory_create_Results, error) {
	p, err := f.Future.Ptr()
	return LoggerFactory_create_Results(p.Struct()), err
}
func (p LoggerFactory_create_Results_Future) Logger() Logger {
	return Logger(p.Future.Field(0, nil).Client())
}

type LoggerRequest capnp.Struct

// LoggerRequest_TypeID is the unique identifier for the type LoggerRequest.
const LoggerRequest_TypeID = 0x9d6f1887acd84ec9

func NewLoggerRequest(s *capnp.Segment) (LoggerRequest, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LoggerRequest(st), err
}

func NewRootLoggerRequest(s *capnp.Segment) (LoggerRequest, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LoggerRequest(st), err
}

func ReadRootLoggerRequest(msg *capnp.Message) (LoggerRequest, error) {
	root, err := msg.Root()
	return LoggerRequest(root.Struct()), err
}

func (s LoggerRequest) String() string {
	str, _ := text.Marshal(0x9d6f1887acd84ec9, capnp.Struct(s))
	return str
}

func (s LoggerRequest) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LoggerRequest) DecodeFromPtr(p capnp.Ptr) LoggerRequest {
	return LoggerRequest(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LoggerRequest) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LoggerRequest) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LoggerRequest) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LoggerRequest) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LoggerRequest) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s LoggerRequest) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LoggerRequest) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s LoggerRequest) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// LoggerRequest_List is a list of LoggerRequest.
type LoggerRequest_List = capnp.StructList[LoggerRequest]

// NewLoggerRequest creates a new list of LoggerRequest.
func NewLoggerRequest_List(s *capnp.Segment, sz int32) (LoggerRequest_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[LoggerRequest](l), err
}

// LoggerRequest_Future is a wrapper for a LoggerRequest promised by a client call.
type LoggerRequest_Future struct{ *capnp.Future }

func (f LoggerRequest_Future) Struct() (LoggerRequest, error) {
	p, err := f.Future.Ptr()
	return LoggerRequest(p.Struct()), err
}

const schema_c44af6dd60b5376e = "x\xda\x8c\x92?h\x14]\x14\xc5\xcf\xbd3\xbb\x9b\x0f" +
	"\xb2\xdf\xe6\xf9V\xa2\x88,\x86\x045\x92\xb0Y\x95\xc0" +
	"6\x1bS\x18\x12\xa2dR\xd8\xd88\xae\xcfQ\x98\xdd" +
	"\x89o6\x86`\x91R-\xd2\x88\x85\x16)\x14l\xa2" +
	"\x85\x8d\x85Z\x09*\x04AT\x08h@\xb0I\xa1\x8d" +
	"VB\"22\xb3Nf\xf0\x0fX\xdd\xe6\xf0\xbb\xf7" +
	"\x9c{\xcae\x1a1\x87\xf2{M\xb0U\xced\x83\xe2" +
	"\xf8\xd2\xa7s\xf5\xf2\x15\x88\xbc\x114\x87\x1f\x9cz\xff" +
	"u\xe2)@r\x83nK\xe2n@\xfe\xc7cr\x88" +
	"s@\xb0r\xfc\xed\xbd\xcb;\xbc%\x88<%\xe2\x0c" +
	"\xe5\x00\xb9\x93\xd7d_\xa8\x92{\xb8\x06\x0a\x1e\x1f\xf8" +
	"\xde\xf7\x7fs|\x19b\x17\xa1\xad9x\x84\xa7\x09$" +
	"\x8fE\x82\x93W?to{t\xe3nZ\xd0\xe0\x89" +
	"P0\x1f\x09\xb2\xf5\xfb\x97FG\xbf\xad@\x149\xb9" +
	"\x13$o\xf2\x1by'Zu\x8b\x17@\xc1\xf5\x13/" +
	"_\xad\xf7\x0f\xadC\x14\x090C\xd0*3\xc1\x0c\xae" +
	"m,\x0e/W\xb3_~s\xf7\x90\xd7\xe4\xb3\x08\xf1" +
	"\x84\xc7\xe4\xc7\xc8]\xe6\xdd\xf3\xcf+/\x167a\x15" +
	")\xbeH\xbe\xe6M\x90\\\xe59\x0c\x04\xae\xe78J" +
	"\x0f\xd6\xc9\x9ei\xceT'='\xe7(m\x99\x94>" +
	"\x95*\xa5IuQ\xb9\x96idRL\x8ao\x14\xa2" +
	"\x07,2\xb9\x9c\xeb9#4E\xb4E\xe5\x98\xea(" +
	"=\xad.\xcc*\xc3oM\x11Y\xa6a\x02&\x01\"" +
	"\xdf\x0fX\x1d\x06YE\xa6B\xd3n(\xea\x04S'" +
	"\x12\x86\x99b\x1c\xb5\xeb-O\xcf\x0f\xd6\xb5\xb2[\xaa" +
	"wZ\xf9\xb3n\x8b\xfc4\xaf\x9a\xf0jm\x04\x89t" +
	"\xd2$\xfe\x8d=ek\xbb\xe1\x03i\xf6h\xc2^\xd0" +
	"\xa1\x1d\xbfE]I\x83@\xd4\x85?\x9b\x1f\x0c\x03$" +
	"7\xf4^$\x06\xc4\xe1Jt\xcb@8X\xf4\xf5\x03" +
	"d\x88\xdd\xe10\xc5\xf6\x0aPji\xbb\xaeJg\xd4" +
	"\xe9Y\xa7p\xbey\xd6+\xcc\xd9\xbaYRZ{z" +
	"kC6\xbd\xc1\xf5\x9c\x9f\x81\xf8\x88\x05\xbf\xda3\xf4" +
	"|;\xfe\xf0\x8fqY)\xae\xb5\x10\xd5\xe8\x8f\xb5v" +
	"\x04\x7f\x7fe\xb4\xab\xd6N\xc8\xea\xd8\xcag\x7f\x05\xb0" +
	"z\x0d\xb2\xcaLDQ\xe1\xc4@\x0f`\xed3\xc8:" +
	"\xc4Tr\xc3\x16Q!\xa9\x16\x88\x0a\xa0\\\xc3w\xe2" +
	"\xb7\xff\x08\x00\x00\xff\xffm\x93\x0b\x1c"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_c44af6dd60b5376e,
		Nodes: []uint64{
			0x88306368ea9d4914,
			0x9d6f1887acd84ec9,
			0xaa496e0e25fd2bbb,
			0xab98ba1217e0895b,
			0xc9fb42427bb06306,
			0xe5312ae5d0ce5694,
			0xf0063aaa378df992,
			0xfa8dcbc9efc6d905,
		},
		Compressed: true,
	})
}
